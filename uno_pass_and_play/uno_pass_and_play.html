<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="theme-color" content="#0a0f18" />
  <link rel="manifest" href="manifest.webmanifest" />
  <title>UNO (Pass-and-Play)</title>
  <style>
    html, body { margin:0; height:100%; background:#111; font-family: system-ui, Segoe UI, Arial; }
    canvas { display:block; margin:0 auto; background:#0b0f14; }
  </style>
</head>
<body>
<canvas id="c" width="1280" height="720"></canvas>
<script>
(() => {
  const W = 1280, H = 720;
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  // ---------- Utilities ----------
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const rnd = (n) => Math.floor(Math.random() * n);
  function shuffle(a) {
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }
  function roundedRect(ctx, x, y, w, h, r) {
    r = Math.min(r, w / 2, h / 2);
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }
  function measureTextFit(text, maxW, basePx) {
    let px = basePx;
    while (px > 10) {
      ctx.font = `700 ${px}px system-ui, Segoe UI, Arial`;
      if (ctx.measureText(text).width <= maxW) return px;
      px -= 1;
    }
    return px;
  }

  // ---------- Assets ----------
  const assets = {
    cardImg: null,
    cardImgReady: false
  };

  (function loadAssets() {
    const img = new Image();
    img.onload = () => {
      assets.cardImg = img;
      assets.cardImgReady = true;
    };
    img.onerror = () => {
      assets.cardImg = null;
      assets.cardImgReady = false;
    };
    img.src = "card.png";
  })();

  // ---------- UNO Model ----------
  const COLORS = ["R","G","B","Y"]; // red, green, blue, yellow
  const COLOR_NAME = { R:"RED", G:"GREEN", B:"BLUE", Y:"YELLOW" };
  const COLOR_FILL = { R:"#e43b3b", G:"#2ecc71", B:"#3498db", Y:"#f1c40f" };
  const DARK_FILL  = { R:"#b32929", G:"#1f8f4c", B:"#246fa3", Y:"#b58f0a" };

  // Card: { color: "R|G|B|Y|W", value: "0-9|S|R|D2|W|WD4" }
  // S = Skip, R = Reverse, D2 = Draw Two, W = Wild, WD4 = Wild Draw Four
  function makeDeck() {
    const deck = [];
    for (const c of COLORS) {
      // one 0
      deck.push({color:c, value:"0"});
      // two of 1-9
      for (let n = 1; n <= 9; n++) {
        deck.push({color:c, value:String(n)});
        deck.push({color:c, value:String(n)});
      }
      // two of each action
      for (let k = 0; k < 2; k++) {
        deck.push({color:c, value:"S"});
        deck.push({color:c, value:"R"});
        deck.push({color:c, value:"D2"});
      }
    }
    // wilds
    for (let i = 0; i < 4; i++) deck.push({color:"W", value:"W"});
    for (let i = 0; i < 4; i++) deck.push({color:"W", value:"WD4"});
    return shuffle(deck);
  }

  function cardLabel(card) {
    if (card.value === "S") return "SKIP";
    if (card.value === "R") return "REVERSE";
    if (card.value === "D2") return "+2";
    if (card.value === "W") return "WILD";
    if (card.value === "WD4") return "WILD +4";
    return card.value;
  }

  function isWild(card) { return card.color === "W"; }
  function isAction(card) { return ["S","R","D2","W","WD4"].includes(card.value); }

  // Rules: can play if matches color OR value OR wild
  function canPlay(card, topCard, activeColor) {
    if (isWild(card)) return true;
    if (card.color === activeColor) return true;
    if (card.value === topCard.value && !isWild(topCard)) return true;
    // if top was wild, matching value isn't meaningful; activeColor handles match
    return false;
  }

  function hasAnyColorMatchForActiveColor(hand, activeColor) {
    return hand.some(c => !isWild(c) && c.color === activeColor);
  }

  // Official-ish restriction: Wild Draw Four can be played only if you have no card
  // matching the current active color.
  function canPlayWildDrawFour(card, hand, activeColor) {
    if (!(card.color === "W" && card.value === "WD4")) return true;
    return !hasAnyColorMatchForActiveColor(hand, activeColor);
  }

  // ---------- Game State ----------
  const state = {
    phase: "title", // title | setup | game | colorPick | handoff | gameOver | tutorial | help
    players: [],
    playerTypes: ["human","ai","ai","ai"],
    aiSpeedMs: 900,
    aiAutoContinue: false,

    // AI turn visualization
    aiQueue: [],
    aiActing: false,
    aiNextAt: 0,
    aiPreview: null,
    aiPreviewUntil: 0,
    playerCount: 4,
    current: 0,
    direction: 1, // 1 clockwise, -1 counter
    deck: [],
    discard: [],
    activeColor: "R",
    pendingDraw: 0,
    pendingSkip: false,
    message: "",
    messageUntil: 0,
    mustDraw: false,      // if true, player must draw (no playable cards)
    hasDrawnThisTurn: false,

    // UNO call rule
    unoRequiredForPlayer: null, // player index who must call UNO now
    unoCallWindow: 0,          // timestamp (ms) when window expires

    // tutorial
    tutorial: {
      enabled: false,
      step: 0,
      expect: null,
      lastHintUntil: 0
    },

    awaitingColorFor: null // card being played requiring color choice
  };

  function resetGame(playerCount, tutorialEnabled=false) {
    state.phase = "game";
    state.playerCount = playerCount;
    state.players = Array.from({length: playerCount}, (_, i) => ({ name: `Player ${i+1}`, hand: [], type: state.playerTypes[i] || "human" }));
    state.current = 0;
    state.direction = 1;
    state.deck = makeDeck();
    state.discard = [];
    state.pendingDraw = 0;
    state.pendingSkip = false;
    state.mustDraw = false;
    state.hasDrawnThisTurn = false;

    state.unoRequiredForPlayer = null;
    state.unoCallWindow = 0;

    state.tutorial.enabled = tutorialEnabled;
    state.tutorial.step = 0;
     state.tutorial.expect = null;
     state.tutorial.lastHintUntil = 0
     state.tutorial._showSkipOverlay = false;
     
     state.awaitingColorFor = null;

    // deal 7 each
    for (let i = 0; i < 7; i++) {
      for (let p = 0; p < playerCount; p++) drawToPlayer(p, 1);
    }

    // flip first discard: should be a number card (simple rule)
    let first = state.deck.pop();
    while (isAction(first)) {
      // put it back somewhere and draw another
      state.deck.unshift(first);
      first = state.deck.pop();
    }
    state.discard.push(first);
    state.activeColor = first.color;

    announce(`${state.players[state.current].name}'s turn`);
    startTurn();
  }

  function announce(msg, ms=1200) {
    state.message = msg;
    state.messageUntil = performance.now() + ms;
  }

  function topDiscard() { return state.discard[state.discard.length - 1]; }

  function recycleDiscardIntoDeck() {
    // Keep top discard, shuffle rest into deck
    if (state.discard.length <= 1) return;
    const top = state.discard.pop();
    const rest = state.discard.splice(0, state.discard.length);
    shuffle(rest);
    state.deck = rest.concat(state.deck);
    state.discard.push(top);
  }

  function drawCard() {
    if (state.deck.length === 0) recycleDiscardIntoDeck();
    return state.deck.pop() || null;
  }

  function drawToPlayer(pIndex, count) {
    for (let i = 0; i < count; i++) {
      const c = drawCard();
      if (c) state.players[pIndex].hand.push(c);
    }
  }

  function nextIndex(from = state.current, steps = 1) {
    const n = state.players.length;
    return (from + state.direction * steps % n + n) % n;
  }

  function applyCardEffect(card) {
    if (card.value === "R") {
      state.direction *= -1;
    } else if (card.value === "S") {
      state.pendingSkip = true;
    } else if (card.value === "D2") {
      state.pendingDraw += 2;
      state.pendingSkip = true; // next player draws and loses turn
    } else if (card.value === "WD4") {
      state.pendingDraw += 4;
      state.pendingSkip = true;
    } else if (card.value === "W") {
      // nothing besides color pick
    }
  }

   function pickBestColorForHand(hand) {
     const counts = { R:0, G:0, B:0, Y:0 };
     for (const c of hand) {
       if (!isWild(c) && counts[c.color] !== undefined) counts[c.color]++;
     }
     let best = "R";
     let bestN = -1;
     for (const col of COLORS) {
       if (counts[col] > bestN) { bestN = counts[col]; best = col; }
     }
     return best;
   }

   function chooseAiCardIndex(hand) {
     const top = topDiscard();
     const activeColor = state.activeColor;

     const playable = [];
     for (let i = 0; i < hand.length; i++) {
       const c = hand[i];
       if (!canPlay(c, top, activeColor)) continue;
       if (!canPlayWildDrawFour(c, hand, activeColor)) continue;
       playable.push({ i, c });
     }
     if (playable.length === 0) return -1;

     // Prefer: non-wild number > non-wild action > wild > wild+4
     const score = (card) => {
       if (card.color === "W" && card.value === "WD4") return 10;
       if (card.color === "W" && card.value === "W") return 8;
       if (card.value === "S" || card.value === "R" || card.value === "D2") return 4;
       return 1;
     };
     playable.sort((a, b) => score(a.c) - score(b.c));
     return playable[0].i;
   }

   function showAiPreview(card, title, ms) {
     state.aiPreview = { card, title };
     state.aiPreviewUntil = performance.now() + ms;
   }

   function clearAiTurn() {
     state.aiQueue.length = 0;
     state.aiActing = false;
     state.aiNextAt = 0;
   }

   function queueAiAction(action) {
     state.aiQueue.push(action);
   }

   function planAiTurn() {
     if (state.phase !== "game") return;
     if (state.tutorial.enabled) return;
     const player = state.players[state.current];
     if (!player || player.type !== "ai") return;

     state.aiQueue.length = 0;
     state.aiActing = true;

     queueAiAction({ type: "think" });

     const hand = player.hand;
     const idx = chooseAiCardIndex(hand);
     if (idx >= 0) {
       queueAiAction({ type: "play", index: idx });
       return;
     }

     // No play: draw once
     queueAiAction({ type: "draw" });
     // After draw we may play the drawn card if it is playable
     queueAiAction({ type: "playDrawnIfPossible" });
     // Otherwise pass
     queueAiAction({ type: "pass" });
   }

   function runAiStep() {
     if (!state.aiActing) return;
     if (state.phase !== "game" && state.phase !== "colorPick") { clearAiTurn(); return; }

     const player = state.players[state.current];
     if (!player || player.type !== "ai" || state.tutorial.enabled) { clearAiTurn(); return; }

     const now = performance.now();
     if (state.aiNextAt && now < state.aiNextAt) return;

     const delay = state.aiSpeedMs ?? 900;
     const action = state.aiQueue.shift();
     if (!action) {
       clearAiTurn();
       return;
     }

     if (action.type === "think") {
       announce(`${player.name} (AI) is thinking...`, Math.max(500, delay));
       state.aiNextAt = now + Math.max(500, delay);
       return;
     }

     if (action.type === "draw") {
       announce(`${player.name} draws`, Math.max(700, delay));
       const before = player.hand.length;
       drawAction();
       // drawAction might end the turn (no play) -> stop
       if (state.phase !== "game") { clearAiTurn(); return; }
       const drawn = player.hand[player.hand.length - 1];
       if (player.hand.length === before + 1 && drawn) {
         showAiPreview(drawn, `${player.name} drew`, Math.max(750, delay));
       }
       state.aiNextAt = now + Math.max(700, delay);
       return;
     }

     if (action.type === "play") {
       const card = player.hand[action.index];
       if (!card) { state.aiNextAt = now + 50; return; }

       // Preview before it lands
       showAiPreview(card, `${player.name} plays`, Math.max(850, delay));
       announce(`${player.name} plays ${isWild(card) ? cardLabel(card) : (COLOR_NAME[card.color] + " " + cardLabel(card))}`, Math.max(850, delay));
       playCardFromHand(action.index);

       // If wild, auto-pick color and finish after a pause
       if (state.phase === "colorPick" && state.awaitingColorFor) {
         const chosen = pickBestColorForHand(player.hand);
         queueAiAction({ type: "chooseColor", color: chosen });
       }

       // Auto-call UNO if needed
       if (state.unoRequiredForPlayer === state.current) {
         state.unoRequiredForPlayer = null;
         state.unoCallWindow = 0;
         announce(`${player.name} calls UNO!`, Math.max(700, delay));
       }

       state.aiNextAt = now + Math.max(850, delay);
       return;
     }

     if (action.type === "chooseColor") {
       const chosen = action.color;
       announce(`${player.name} chooses ${COLOR_NAME[chosen]}`, Math.max(700, delay));
       state.activeColor = chosen;
       state.awaitingColorFor = null;
       state.phase = "game";
       endTurn(false);
       state.aiNextAt = now + Math.max(700, delay);
       clearAiTurn();
       return;
     }

     if (action.type === "playDrawnIfPossible") {
       const idx = player.hand.length - 1;
       const c = player.hand[idx];
       if (c && canPlay(c, topDiscard(), state.activeColor) && canPlayWildDrawFour(c, player.hand, state.activeColor)) {
         queueAiAction({ type: "play", index: idx });
       }
       state.aiNextAt = now + 50;
       return;
     }

     if (action.type === "pass") {
       announce(`${player.name} passes`, Math.max(600, delay));
       endTurn(false);
       clearAiTurn();
       return;
     }
   }

   function startTurn() {
     state.hasDrawnThisTurn = false;
     state.mustDraw = false;

    // UNO penalty if player failed to call UNO during their previous turn.
    if (state.unoRequiredForPlayer === state.current && performance.now() > state.unoCallWindow) {
      drawToPlayer(state.current, 2);
      announce("UNO penalty: drew 2", 1400);
      state.unoRequiredForPlayer = null;
      state.unoCallWindow = 0;
    }

    // If there is a pending draw/skip from previous play, apply to current player immediately
    if (state.pendingDraw > 0) {
      drawToPlayer(state.current, state.pendingDraw);
      announce(`${state.players[state.current].name} draws ${state.pendingDraw}`);
      state.pendingDraw = 0;
      // Their turn is skipped by rule (we model via pendingSkip)
    }
    if (state.pendingSkip) {
      // Skip this player entirely and advance to the next.
      // Important: do NOT trigger endTurn() here, because endTurn() also advances
      // and can get the tutorial stuck on the "skip explanation" step.
      state.pendingSkip = false;
      state.current = nextIndex(state.current, 1);
      state.phase = "handoff";
      state.handoffTo = state.players[state.current].name;
      state.handoffStart = performance.now();
      return;
    }

     // Determine if player has any playable cards; if none, they must draw once
     const player = state.players[state.current];
     const hand = player.hand;
     const playable = hand.some(c => canPlay(c, topDiscard(), state.activeColor));
     if (!playable) {
       state.mustDraw = true;
       announce("No plays: draw a card", 1200);
     } else {
       announce(`${player.name}: play a card or draw`);
     }

     // Auto-play for AI players in normal games
     if (player.type === "ai" && !state.tutorial.enabled) {
       planAiTurn();
     }
   }

  function endTurn() {
    // Check win
    const hand = state.players[state.current].hand;
    if (hand.length === 0) {
      state.phase = "gameOver";
      state.winner = state.players[state.current].name;
      return;
    }

    // Move to next player
    state.current = nextIndex(state.current, 1);

     // Tutorial: after Player 2 plays Skip, we jump straight to Player 4
     // and show the explanation overlay (no Player 3 interaction).
     if (state.tutorial.enabled && state.tutorial.step === 2 && state.tutorial._showSkipOverlay) {
       state.tutorial._showSkipOverlay = false;
       state.phase = "tutorial";
       return;
     }

    state.phase = "handoff";
    state.handoffTo = state.players[state.current].name;
    state.handoffStart = performance.now();
  }

  function playCardFromHand(handIndex) {
    const player = state.players[state.current];
    const card = player.hand[handIndex];
    const top = topDiscard();

    // Tutorial gating (only allow the required play to progress)
    if (state.tutorial.enabled) {
      const s = state.tutorial.step;
      const isP1 = state.current === 0;
      const isP2 = state.current === 1;
      const isP3 = state.current === 2;
      const isP4 = state.current === 3;

      if (s === 0 && !(isP1 && card.color === "R" && card.value === "9")) {
        announce("Tutorial: Player 1 must play RED 9", 1400);
        return;
      }
       if (s === 1 && !(isP2 && card.color === "R" && card.value === "S")) {
         announce("Tutorial: Player 2 must play RED SKIP", 1400);
         return;
       }
       // Step 2 is informational only; show it after the skip resolves.
       if (s === 2) {
         // any action is blocked until CONTINUE is clicked
         announce("Tutorial: click CONTINUE", 1200);
         return;
       }
      if (s === 3 && !(isP4 && card.color === "W" && card.value === "W")) {
        announce("Tutorial: Player 4 must play WILD", 1400);
        return;
      }

      // Step 5: encourage reaching UNO by playing one card (we'll inject a forced second card)
      if (s === 5 && isP1) {
        // allow any playable, but after they play it we will force them to 1 card
        // so UNO button must be clicked.
      }

      // Step 6: show illegal +4, then force RED 0
      if (s === 6 && isP3) {
        if (card.color === "W" && card.value === "WD4") {
          // Should be blocked by rules; but make the reason explicit
          if (!canPlayWildDrawFour(card, player.hand, state.activeColor)) {
            announce("Correct: +4 is illegal while you have a RED card", 1700);
            return;
          }
        }
        if (!(card.color === "R" && card.value === "0")) {
          announce("Tutorial: Player 3 must play RED 0", 1400);
          return;
        }
      }

      // Step 7: now +4 should be allowed after RED 0 is gone
      if (s === 7 && !(isP3 && card.color === "W" && card.value === "WD4")) {
        announce("Tutorial: Player 3 must now play WILD +4", 1400);
        return;
      }
    }

    if (!canPlay(card, top, state.activeColor)) {
      announce("Can't play that", 900);
      return;
    }
    if (!canPlayWildDrawFour(card, player.hand, state.activeColor)) {
      announce("Wild +4 not allowed (you have a color match)", 1400);
      return;
    }

    // Remove from hand, place on discard
    player.hand.splice(handIndex, 1);
    state.discard.push(card);

    // Tutorial: on step 5, force the hand to exactly 1 card after playing.
    // This makes the UNO demo deterministic.
    if (state.tutorial.enabled && state.tutorial.step === 5 && state.current === 0) {
      // Ensure player has exactly 1 card remaining.
      while (player.hand.length > 1) player.hand.pop();
    }

    // UNO call requirement: when you PLAY down to 1 card, you must call UNO.
    // If you forget (don't click UNO in time), you draw 2 at start of your next turn.
    if (player.hand.length === 1) {
      state.unoRequiredForPlayer = state.current;
      state.unoCallWindow = performance.now() + 5000; // 5 seconds to call
      announce("UNO! Click the UNO button", 1600);

      // Tutorial step 5 waits for UNO call.
      if (state.tutorial.enabled && state.tutorial.step === 5) {
        announce("Now click UNO!", 1600);
      }
    }

    // Tutorial auto-advance on correct plays
    if (state.tutorial.enabled) {
      const s = state.tutorial.step;
       if (s === 0 && state.current === 0 && card.color === "R" && card.value === "9") tutorialAdvanceIf(true);
        else if (s === 1 && state.current === 1 && card.color === "R" && card.value === "S") {
         // Next is the auto-skip explanation step.
         tutorialAdvanceIf(true);
         // Mark that the upcoming skip is intentional so we can show the overlay.
         state.tutorial._showSkipOverlay = true;
       }
      else if (s === 3 && state.current === 3 && card.color === "W" && card.value === "W") {
        // Color pick will advance this step.
      }
      else if (s === 5 && state.current === 0) {
        // After this play we force the player to 1 card; UNO button advances.
      }
      else if (s === 6 && state.current === 2 && card.color === "R" && card.value === "0") tutorialAdvanceIf(true);
      // step 7 advances after playing WD4 and choosing color (handled in color pick)
    }

    // Set activeColor
    if (isWild(card)) {
      state.awaitingColorFor = card;
      state.phase = "colorPick";
      announce("Choose a color", 900);
      applyCardEffect(card);
      return;
    } else {
      state.activeColor = card.color;
    }

    applyCardEffect(card);
    endTurn(false);
  }

  function drawAction() {
    if (state.tutorial.enabled) {
      // during the draw step, force it to be Player 1
      if (state.tutorial.step === 4 && state.current !== 0) {
        announce("Tutorial: wait for Player 1", 1400);
        return;
      }
      if (state.tutorial.step !== 4) {
        announce("Tutorial: drawing is not needed yet", 1400);
        return;
      }
    }

    if (state.deck.length === 0) recycleDiscardIntoDeck();
    const c = drawCard();
    if (!c) return;

    const hand = state.players[state.current].hand;
    hand.push(c);
    state.hasDrawnThisTurn = true;

    if (state.tutorial.enabled && state.tutorial.step === 4) {
      // After drawing once, move to UNO demo.
      state.tutorial.step = 5;
      announce("Next: play a card to reach UNO", 1500);
    }

    // If they had to draw (no plays), allow auto-play if playable; else end turn.
    if (state.mustDraw) {
      state.mustDraw = false;
      if (canPlay(c, topDiscard(), state.activeColor)) {
        announce("Drew playable card: you may play it", 1200);
      } else {
        announce("Drew no play: turn passes", 1200);
        endTurn(false);
      }
    } else {
      announce("Card drawn", 800);
    }
  }

  // ---------- UI ----------
  const ui = {
    hoveredCard: -1,
    mouseX: 0, mouseY: 0,
    down: false,
    justDown: false,
    justUp: false
  };

  canvas.addEventListener("mousemove", (e) => {
    const rect = canvas.getBoundingClientRect();
    ui.mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
    ui.mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
  });
  canvas.addEventListener("mousedown", () => { ui.down = true; ui.justDown = true; });
  canvas.addEventListener("mouseup", () => { ui.down = false; ui.justUp = true; });

  // Prevent right-click menu from interrupting clicks.
  canvas.addEventListener("contextmenu", (e) => e.preventDefault());

  // ---------- PWA install + offline ----------
  let deferredInstallPrompt = null;

  function pwaInstallSupported() {
    return "serviceWorker" in navigator && ("BeforeInstallPromptEvent" in window || true);
  }

  function pwaInstallAvailable() {
    return !!deferredInstallPrompt;
  }

  async function pwaPromptInstall() {
    if (!deferredInstallPrompt) return false;
    try {
      deferredInstallPrompt.prompt();
      const choice = await deferredInstallPrompt.userChoice;
      deferredInstallPrompt = null;
      return choice && choice.outcome === "accepted";
    } catch {
      deferredInstallPrompt = null;
      return false;
    }
  }

  window.addEventListener("beforeinstallprompt", (e) => {
    // Chrome/Edge: allow us to show a custom "Install" UI.
    e.preventDefault();
    deferredInstallPrompt = e;
  });

  window.addEventListener("appinstalled", () => {
    deferredInstallPrompt = null;
  });

  // Register the service worker for offline support.
  if ("serviceWorker" in navigator) {
    window.addEventListener("load", () => {
      navigator.serviceWorker.register("sw.js").catch(() => {
        // ignore
      });
    });
  }

  const buttons = [];
  function addButton(id, x, y, w, h, label, onClick) {
    buttons.push({id, x, y, w, h, label, onClick, disabled:false});
  }
  function hitRect(mx,my, r) { return mx>=r.x && mx<=r.x+r.w && my>=r.y && my<=r.y+r.h; }

  function drawButton(b) {
    const hover = hitRect(ui.mouseX, ui.mouseY, b);
    ctx.save();
    ctx.globalAlpha = b.disabled ? 0.45 : 1;
    roundedRect(ctx, b.x, b.y, b.w, b.h, 10);
    ctx.fillStyle = hover ? "#2b3340" : "#222a36";
    ctx.fill();
    ctx.strokeStyle = "#475067";
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.fillStyle = "#e8eefc";
    ctx.font = "700 18px system-ui, Segoe UI, Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(b.label, b.x + b.w/2, b.y + b.h/2);
    ctx.restore();
  }

  function drawCardFace(card, x, y, w, h, options={}) {
    const {dim=false, outline=true} = options;
    const fill = isWild(card) ? "#111" : COLOR_FILL[card.color];
    const dark = isWild(card) ? "#000" : DARK_FILL[card.color];

    ctx.save();
    ctx.globalAlpha = dim ? 0.5 : 1;

    // Base: use card.png as the card frame/background when available.
    if (assets.cardImgReady && assets.cardImg) {
      roundedRect(ctx, x, y, w, h, 18);
      ctx.clip();
      ctx.drawImage(assets.cardImg, x, y, w, h);
    } else {
      roundedRect(ctx, x, y, w, h, 18);
      ctx.fillStyle = "#0f1622";
      ctx.fill();
    }

    if (outline) {
      ctx.globalAlpha = dim ? 0.5 : 1;
      roundedRect(ctx, x, y, w, h, 18);
      ctx.strokeStyle = "#0e0e0e";
      ctx.lineWidth = 3;
      ctx.stroke();
    }

    // Color panel (inside the frame)
    const framePad = 12;
    roundedRect(ctx, x+framePad, y+framePad, w-framePad*2, h-framePad*2, 14);
    ctx.fillStyle = fill;
    ctx.globalAlpha = dim ? 0.5 : 0.95;
    ctx.fill();

    // Inner darker panel for contrast
    const innerPad = 22;
    roundedRect(ctx, x+innerPad, y+innerPad, w-innerPad*2, h-innerPad*2, 12);
    ctx.fillStyle = dark;
    ctx.globalAlpha = dim ? 0.5 : 0.95;
    ctx.fill();

    // label
    ctx.globalAlpha = dim ? 0.5 : 1;
    const lbl = cardLabel(card);
    const px = measureTextFit(lbl, w-30, 32);
    ctx.font = `800 ${px}px system-ui, Segoe UI, Arial`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "#fff";
    ctx.fillText(lbl, x + w/2, y + h/2);

    // wild color pips
    if (isWild(card)) {
      const pip = 14;
      const gap = 8;
      const cx = x + w/2, cy = y + h/2 + 28;
      const cols = ["R","G","B","Y"];
      const totalW = cols.length * pip*2 + (cols.length-1)*gap;
      let start = cx - totalW/2 + pip;
      for (let i = 0; i < cols.length; i++) {
        ctx.beginPath();
        ctx.arc(start + i*(pip*2+gap), cy, pip, 0, Math.PI*2);
        ctx.fillStyle = COLOR_FILL[cols[i]];
        ctx.fill();
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    }

    ctx.restore();
  }

  function drawCardBack(x, y, w, h) {
    ctx.save();

    if (assets.cardImgReady && assets.cardImg) {
      roundedRect(ctx, x, y, w, h, 18);
      ctx.clip();
      ctx.drawImage(assets.cardImg, x, y, w, h);
    } else {
      roundedRect(ctx, x, y, w, h, 18);
      ctx.fillStyle = "#0f1622";
      ctx.fill();
    }

    roundedRect(ctx, x, y, w, h, 18);
    ctx.strokeStyle = "#0a0f18";
    ctx.lineWidth = 3;
    ctx.stroke();

    // centered mark
    const pad = 22;
    roundedRect(ctx, x+pad, y+pad, w-pad*2, h-pad*2, 12);
    ctx.fillStyle = "rgba(12,18,28,0.7)";
    ctx.fill();

    ctx.fillStyle = "#e8eefc";
    ctx.font = "900 26px system-ui, Segoe UI, Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("UNO", x + w/2, y + h/2);
    ctx.restore();
  }

  function drawHeader() {
    ctx.save();
    ctx.fillStyle = "#0a0f18";
    ctx.fillRect(0, 0, W, 86);

    ctx.fillStyle = "#e8eefc";
    ctx.font = "900 24px system-ui, Segoe UI, Arial";
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    ctx.fillText("UNO — Pass-and-Play", 24, 42);

    ctx.font = "700 16px system-ui, Segoe UI, Arial";
    ctx.fillStyle = "#b9c6e6";
    ctx.fillText(`Turn: ${state.players[state.current]?.name || ""}`, 320, 30);
    ctx.fillText(`Active color: ${COLOR_NAME[state.activeColor]}`, 320, 56);

    ctx.textAlign = "right";
    ctx.fillText(`Deck: ${state.deck.length}`, W - 24, 30);
    ctx.fillText(`Discard: ${state.discard.length}`, W - 24, 56);

    // Header button hit area (rendered in renderTable/renderHelp)
    // Keep it left of the deck/discard counters.
    state._helpBtn = { x: W - 260, y: 20, w: 100, h: 46 };
    state._installBtn = { x: W - 380, y: 20, w: 110, h: 46 };

    ctx.restore();
  }

  function drawCenteredOverlay(title, subtitle, buttonsSpec) {
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.65)";
    ctx.fillRect(0,0,W,H);

    // Auto-size box to fit button row
    const bw = 220, bh = 54, gap = 18;
    const rowW = buttonsSpec.length * bw + Math.max(0, buttonsSpec.length - 1) * gap;
    const boxW = Math.max(720, rowW + 120);
    const boxH = 380;
    const x = (W - boxW)/2, y = (H - boxH)/2;
    roundedRect(ctx, x, y, boxW, boxH, 18);
    ctx.fillStyle = "#151c27";
    ctx.fill();
    ctx.strokeStyle = "#334058";
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.fillStyle = "#e8eefc";
    ctx.font = "900 40px system-ui, Segoe UI, Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(title, W/2, y + 90);

    ctx.fillStyle = "#b9c6e6";
    ctx.font = "600 18px system-ui, Segoe UI, Arial";
    ctx.fillText(subtitle, W/2, y + 140);

    const totalW = buttonsSpec.length * bw + (buttonsSpec.length-1)*gap;
    let sx = W/2 - totalW/2;
    buttonsSpec.forEach((b, i) => {
      const bx = sx + i*(bw+gap), by = y + 220;
      roundedRect(ctx, bx, by, bw, bh, 12);
      const hover = ui.mouseX>=bx && ui.mouseX<=bx+bw && ui.mouseY>=by && ui.mouseY<=by+bh;
      ctx.fillStyle = hover ? "#2b3340" : "#222a36";
      ctx.fill();
      ctx.strokeStyle = "#475067";
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.fillStyle = "#e8eefc";
      ctx.font = "800 18px system-ui, Segoe UI, Arial";
      ctx.fillText(b.label, bx+bw/2, by+bh/2);
      if (ui.justUp && hover) b.onClick();
    });

    ctx.restore();
  }

  function layout() {
    const tableTop = 100;
    const pileW = 120, pileH = 170;
    const centerX = W/2;
    const pileY = tableTop + 80;
    const deckRect = { x: centerX - 160, y: pileY, w: pileW, h: pileH };
    const discardRect = { x: centerX + 40, y: pileY, w: pileW, h: pileH };
    const handY = H - 220;
    return { tableTop, deckRect, discardRect, handY };
  }

  function computeHandCardRects(hand) {
    const { handY } = layout();
    const cardW = 105, cardH = 160;
    const padX = 34;

    const maxSpan = W - padX*2;
    const count = hand.length;
    const idealGap = 18;
    const span = count * cardW + (count-1)*idealGap;
    const gap = (span <= maxSpan) ? idealGap : Math.max(6, (maxSpan - count*cardW) / Math.max(1,(count-1)));

    const total = count * cardW + (count-1)*gap;
    let x = (W - total) / 2;
    const y = handY + 18;

    const rects = [];
    for (let i = 0; i < count; i++) {
      rects.push({ x: x + i*(cardW+gap), y, w: cardW, h: cardH });
    }
    return rects;
  }

  function updateButtons() {
    buttons.length = 0;
    const { deckRect } = layout();

     if (state.phase === "game" || state.phase === "tutorial") {
       // AI controls (only in normal games)
       const controlX = deckRect.x + 10;
       const controlW = deckRect.w + 120;
       if (state.phase === "game") {
         addButton("aiAuto", controlX, deckRect.y - 170, controlW, 46,
           state.aiAutoContinue ? "AI CONTINUE: AUTO" : "AI CONTINUE: CLICK",
           () => { state.aiAutoContinue = !state.aiAutoContinue; }
         );

         addButton("aiSpeed", controlX, deckRect.y - 120, controlW, 46,
           `AI SPEED: ${Math.round((state.aiSpeedMs ?? 900) / 100) / 10}s`,
           () => {
             const cycle = [600, 900, 1300, 1800];
             const cur = state.aiSpeedMs ?? 900;
             const idx = Math.max(0, cycle.indexOf(cur));
             state.aiSpeedMs = cycle[(idx + 1) % cycle.length];
           }
         );
       }

       addButton("draw", deckRect.x - 10, deckRect.y + deckRect.h + 18, deckRect.w + 20, 46,
        state.mustDraw ? "DRAW (required)" : "DRAW",
        () => {
          if (state.phase !== "game" && state.phase !== "tutorial") return;
          if (state.hasDrawnThisTurn && !state.mustDraw) {
            announce("Already drew", 700);
            return;
          }
          drawAction();
        }
      );

      addButton("pass", deckRect.x - 10, deckRect.y + deckRect.h + 70, deckRect.w + 20, 46,
        "PASS",
        () => {
          if (state.phase !== "game" && state.phase !== "tutorial") return;
          if (state.hasDrawnThisTurn) {
            endTurn(false);
          } else {
            announce("Draw first (or play)", 1000);
          }
        }
      );

       // UNO call button (place next to PASS)
       addButton("uno", deckRect.x + deckRect.w + 26, deckRect.y + deckRect.h + 70, 140, 46,
         "UNO!",
         () => {
          if (state.phase !== "game" && state.phase !== "tutorial") return;
          if (state.unoRequiredForPlayer !== state.current) {
            announce("UNO not required", 900);
            return;
          }
          if (performance.now() > state.unoCallWindow) {
            announce("Too late", 900);
            return;
          }
          state.unoRequiredForPlayer = null;
          state.unoCallWindow = 0;
          announce("UNO called!", 900);

          if (state.tutorial.enabled && state.tutorial.step === 5) {
            tutorialAdvanceIf(true);
          }
        }
      );

      const pass = buttons.find(b => b.id === "pass");
      if (pass) pass.disabled = !state.hasDrawnThisTurn;

       const uno = buttons.find(b => b.id === "uno");
       if (uno) uno.disabled = !(state.unoRequiredForPlayer === state.current);

       // Make the AI control widths update friendly
       const aiAuto = buttons.find(b => b.id === "aiAuto");
       const aiSpeed = buttons.find(b => b.id === "aiSpeed");
       if (aiAuto) { aiAuto.x = controlX; aiAuto.w = controlW; }
       if (aiSpeed) { aiSpeed.x = controlX; aiSpeed.w = controlW; }
    }
  }

  function renderHelpButtonInHeader() {
    const b = state._helpBtn;
    if (!b) return;

    const hover = hitRect(ui.mouseX, ui.mouseY, b);
    ctx.save();
    roundedRect(ctx, b.x, b.y, b.w, b.h, 12);
    ctx.fillStyle = hover ? "#2b3340" : "#222a36";
    ctx.fill();
    ctx.strokeStyle = "#475067";
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.fillStyle = "#e8eefc";
    ctx.font = "800 16px system-ui, Segoe UI, Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("HELP", b.x + b.w/2, b.y + b.h/2);
    ctx.restore();

    if (ui.justUp && hover) {
      const opened = window.open("UNO_HELP.html", "_blank", "noopener,noreferrer");
      if (!opened) state.phase = "help";
    }
  }

  function renderInstallButtonInHeader() {
    const b = state._installBtn;
    if (!b) return;

    // Only show when the platform fires beforeinstallprompt (Chrome/Edge).
    if (!pwaInstallAvailable()) return;

    const hover = hitRect(ui.mouseX, ui.mouseY, b);
    ctx.save();
    roundedRect(ctx, b.x, b.y, b.w, b.h, 12);
    ctx.fillStyle = hover ? "#2b3340" : "#222a36";
    ctx.fill();
    ctx.strokeStyle = "#475067";
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.fillStyle = "#e8eefc";
    ctx.font = "800 16px system-ui, Segoe UI, Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("INSTALL", b.x + b.w/2, b.y + b.h/2);
    ctx.restore();

    if (ui.justUp && hover) {
      pwaPromptInstall();
    }
  }

  function renderTable() {
     ctx.clearRect(0,0,W,H);
     drawHeader();
     renderInstallButtonInHeader();
     renderHelpButtonInHeader();

     // AI preview card (large) near the discard
     if (state.aiPreview && performance.now() < state.aiPreviewUntil) {
       const { discardRect } = layout();
       const w = 180, h = 270;
       const x = discardRect.x + discardRect.w + 40;
       const y = discardRect.y - 40;
       drawCardFace(state.aiPreview.card, x, y, w, h);
       ctx.save();
       ctx.fillStyle = "rgba(0,0,0,0.35)";
       roundedRect(ctx, x - 6, y - 44, w + 12, 38, 10);
       ctx.fill();
       ctx.fillStyle = "#e8eefc";
       ctx.font = "800 16px system-ui, Segoe UI, Arial";
       ctx.textAlign = "center";
       ctx.textBaseline = "middle";
       ctx.fillText(state.aiPreview.title, x + w/2, y - 25);
       ctx.restore();
     }

    const { deckRect, discardRect } = layout();

    drawCardBack(deckRect.x, deckRect.y, deckRect.w, deckRect.h);

    const top = topDiscard();
    drawCardFace(top, discardRect.x, discardRect.y, discardRect.w, discardRect.h);

    const hoverDeck = hitRect(ui.mouseX, ui.mouseY, deckRect);
    if (hoverDeck) {
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.35)";
      ctx.lineWidth = 3;
      roundedRect(ctx, deckRect.x-2, deckRect.y-2, deckRect.w+4, deckRect.h+4, 18);
      ctx.stroke();
      ctx.restore();
    }
    if (ui.justUp && hoverDeck && (state.phase === "game" || state.phase === "tutorial")) {
      // Let the explicit DRAW button own draw rules/tutorial gating.
      if (state.mustDraw || !state.hasDrawnThisTurn) drawAction();
    }

    // player summary row
    const tableTop = 92;
    const oppY = tableTop + 20;
    if (state.players.length > 1) {
      ctx.save();
      ctx.font = "700 16px system-ui, Segoe UI, Arial";
      ctx.fillStyle = "#b9c6e6";
      ctx.textAlign = "center";
      const boxW = 220, boxH = 60, gap = 16;
      const total = state.players.length * boxW + (state.players.length-1)*gap;
      let x = W/2 - total/2;
      for (let i = 0; i < state.players.length; i++) {
        const p = state.players[i];
        const isCur = i === state.current;
        roundedRect(ctx, x, oppY, boxW, boxH, 12);
        ctx.fillStyle = isCur ? "#24304a" : "#151c27";
        ctx.fill();
        ctx.strokeStyle = isCur ? "#6ea0ff" : "#334058";
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = "#e8eefc";
        ctx.fillText(p.name, x + boxW/2, oppY + 22);
        ctx.fillStyle = "#b9c6e6";
        ctx.fillText(`${p.hand.length} cards`, x + boxW/2, oppY + 44);
        x += boxW + gap;
      }
      ctx.restore();
    }

    // current player's hand
    const player = state.players[state.current];
    const hand = player.hand;
    const rects = computeHandCardRects(hand);

    ui.hoveredCard = -1;
    for (let i = 0; i < rects.length; i++) {
      if (hitRect(ui.mouseX, ui.mouseY, rects[i])) ui.hoveredCard = i;
    }

    for (let i = 0; i < hand.length; i++) {
      const r = rects[i];
      const c = hand[i];
      const playable = canPlay(c, topDiscard(), state.activeColor);
      const isHover = (i === ui.hoveredCard);
      const lift = isHover ? 14 : 0;
      drawCardFace(c, r.x, r.y - lift, r.w, r.h, { dim: !playable && state.phase==="game" });

      if (isHover) {
        ctx.save();
        ctx.strokeStyle = playable ? "rgba(255,255,255,0.8)" : "rgba(255,255,255,0.25)";
        ctx.lineWidth = 3;
        roundedRect(ctx, r.x-2, r.y - lift - 2, r.w+4, r.h+4, 18);
        ctx.stroke();
        ctx.restore();
      }
    }

    updateButtons();
    buttons.forEach(drawButton);

    if (performance.now() < state.messageUntil && state.message) {
      ctx.save();
      ctx.globalAlpha = 0.95;
      // Keep the message toast away from the bottom hand.
      const msgW = 420, msgH = 54;
      const msgX = 22;
      const msgY = layout().handY - 70;
      roundedRect(ctx, msgX, msgY, msgW, msgH, 12);
      ctx.fillStyle = "#151c27";
      ctx.fill();
      ctx.strokeStyle = "#334058";
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.fillStyle = "#e8eefc";
      ctx.font = "700 18px system-ui, Segoe UI, Arial";
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";
      ctx.fillText(state.message, msgX + 18, msgY + msgH/2);
      ctx.restore();
    }
  }

   function renderColorPick() {
     // If an AI played a wild (outside the tutorial), auto-pick a color.
     const cur = state.players[state.current];
     if (cur?.type === "ai" && !state.tutorial.enabled) {
       state.activeColor = pickBestColorForHand(cur.hand);
       state.awaitingColorFor = null;
       state.phase = "game";
       endTurn(false);
       return;
     }

     renderTable();
     ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.65)";
    ctx.fillRect(0,0,W,H);

    const boxW = 640, boxH = 320;
    const x = (W - boxW)/2, y = (H - boxH)/2;
    roundedRect(ctx, x, y, boxW, boxH, 18);
    ctx.fillStyle = "#151c27";
    ctx.fill();
    ctx.strokeStyle = "#334058";
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.fillStyle = "#e8eefc";
    ctx.font = "900 30px system-ui, Segoe UI, Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("Choose a color", W/2, y + 70);

    const bw = 130, bh = 130, gap = 20;
    const total = 4*bw + 3*gap;
    let sx = W/2 - total/2;
    const by = y + 120;
    COLORS.forEach((c, i) => {
      const bx = sx + i*(bw+gap);
      const hover = ui.mouseX>=bx && ui.mouseX<=bx+bw && ui.mouseY>=by && ui.mouseY<=by+bh;
      roundedRect(ctx, bx, by, bw, bh, 18);
      ctx.fillStyle = hover ? COLOR_FILL[c] : DARK_FILL[c];
      ctx.fill();
      ctx.strokeStyle = "#0e0e0e";
      ctx.lineWidth = 3;
      ctx.stroke();

      ctx.fillStyle = "#fff";
      ctx.font = "900 20px system-ui, Segoe UI, Arial";
      ctx.fillText(COLOR_NAME[c], bx + bw/2, by + bh/2);

      if (ui.justUp && hover) {
        state.activeColor = c;
        state.awaitingColorFor = null;

        // Tutorial: advance when the required Wild color pick happens
        if (state.tutorial.enabled) {
          if (state.tutorial.step === 3) {
            // Step 4 was: play WILD and choose BLUE
            if (c !== "B") {
              announce("Tutorial: choose BLUE", 1400);
              return;
            }
            tutorialAdvanceIf(true);
          } else if (state.tutorial.step === 7) {
            // After WILD +4: any color is fine
            tutorialAdvanceIf(true);
          }
        }

        state.phase = state.tutorial.enabled ? "tutorial" : "game";
        endTurn(false);
      }
    });

    ctx.restore();
  }

   function renderHandoff() {
     // Optional auto-continue for AI turns.
     if (!state.tutorial.enabled && state.aiAutoContinue) {
       const cur = state.players[state.current];
       if (cur?.type === "ai") {
         if (!state._aiContinueAt) state._aiContinueAt = performance.now() + Math.max(350, state.aiSpeedMs ?? 900);
         if (performance.now() >= state._aiContinueAt) {
           state._aiContinueAt = 0;
           state.phase = "game";
           startTurn();
           return;
         }
       } else {
         state._aiContinueAt = 0;
       }
     } else {
       state._aiContinueAt = 0;
     }

     renderTable();
     drawCenteredOverlay("Pass Device", `Next: ${state.handoffTo} (click to continue)`, [
       { label: "CONTINUE", onClick: () => {
           state.phase = state.tutorial.enabled ? "tutorial" : "game";
           startTurn();

           // Tutorial step 2: ensure the skip explanation overlay appears.
           // If Player 2 played SKIP, Player 3's turn will be auto-skipped inside startTurn(),
           // so we force the tutorial overlay immediately after that resolution.
           if (state.tutorial.enabled && state.tutorial.step === 2 && state.tutorial._showSkipOverlay) {
             state.tutorial._showSkipOverlay = false;
             state.phase = "tutorial";
           }
         }
       }
     ]);
   }

   function renderTitle() {
     drawCenteredOverlay("UNO", "Pass-and-play (4 players) — or try tutorial", [
       { label: "START 4P", onClick: () => { resetGame(4, false); } },
       { label: "TUTORIAL 4P", onClick: () => { resetGame(4, true); state.phase = "tutorial"; } },
       { label: "SETUP", onClick: () => { state.phase = "setup"; } },
       { label: "HELP", onClick: () => {
           // Prefer opening the standalone help file; fallback if blocked.
           const opened = window.open("UNO_HELP.html", "_blank", "noopener,noreferrer");
           if (!opened) state.phase = "help";
         } }
     ]);
   }

   function renderGameOver() {
     renderTable();
     drawCenteredOverlay("Game Over", `${state.winner} wins!`, [
       { label: "MAIN MENU", onClick: () => { state.phase = "title"; } },
       { label: "RESTART 4P", onClick: () => { resetGame(4, false); } },
       { label: "TUTORIAL", onClick: () => { resetGame(4, true); state.phase = "tutorial"; } },
       { label: "SETUP", onClick: () => { state.phase = "setup"; } },
       { label: "HELP", onClick: () => {
           const opened = window.open("UNO_HELP.html", "_blank", "noopener,noreferrer");
           if (!opened) state.phase = "help";
         } }
     ]);
   }

   function renderSetup() {
     const label = (t) => t === "ai" ? "AI" : "HUMAN";

     ctx.save();
     ctx.fillStyle = "rgba(0,0,0,0.65)";
     ctx.fillRect(0, 0, W, H);

     const boxW = 860, boxH = 470;
     const x = (W - boxW) / 2;
     const y = (H - boxH) / 2 - 12;
     roundedRect(ctx, x, y, boxW, boxH, 18);
     ctx.fillStyle = "#151c27";
     ctx.fill();
     ctx.strokeStyle = "#334058";
     ctx.lineWidth = 2;
     ctx.stroke();

     ctx.fillStyle = "#e8eefc";
     ctx.font = "900 38px system-ui, Segoe UI, Arial";
     ctx.textAlign = "center";
     ctx.textBaseline = "middle";
     ctx.fillText("Setup", W / 2, y + 80);

     ctx.fillStyle = "#b9c6e6";
     ctx.font = "650 18px system-ui, Segoe UI, Arial";
     ctx.fillText("Choose Human/AI for each player", W / 2, y + 125);

     // Toggles
     const bw = 240, bh = 54, gapY = 10;
     const startY = y + 140;
     for (let i = 0; i < 4; i++) {
       const bx = W / 2 - bw / 2;
       const by = startY + i * (bh + gapY);
       const hover = ui.mouseX >= bx && ui.mouseX <= bx + bw && ui.mouseY >= by && ui.mouseY <= by + bh;
       roundedRect(ctx, bx, by, bw, bh, 12);
       ctx.fillStyle = hover ? "#2b3340" : "#222a36";
       ctx.fill();
       ctx.strokeStyle = "#475067";
       ctx.lineWidth = 2;
       ctx.stroke();

       ctx.fillStyle = "#e8eefc";
       ctx.font = "800 18px system-ui, Segoe UI, Arial";
       ctx.fillText(`P${i + 1}: ${label(state.playerTypes[i])}`, bx + bw / 2, by + bh / 2);

       if (ui.justUp && hover) {
         state.playerTypes[i] = state.playerTypes[i] === "ai" ? "human" : "ai";
       }
     }

     // Footer actions
     const smallW = 200, smallH = 54, gapX = 16;
     const total = 3 * smallW + 2 * gapX;
     let sx = W / 2 - total / 2;
     const by = y + boxH - 78;
     const actions = [
       { label: "BACK", onClick: () => { state.phase = "title"; } },
       { label: "START", onClick: () => { resetGame(4, false); } },
       { label: "HELP", onClick: () => {
           const opened = window.open("UNO_HELP.html", "_blank", "noopener,noreferrer");
           if (!opened) state.phase = "help";
         } }
     ];
     actions.forEach((b, i) => {
       const bx = sx + i * (smallW + gapX);
       const hover = ui.mouseX >= bx && ui.mouseX <= bx + smallW && ui.mouseY >= by && ui.mouseY <= by + smallH;
       roundedRect(ctx, bx, by, smallW, smallH, 12);
       ctx.fillStyle = hover ? "#2b3340" : "#222a36";
       ctx.fill();
       ctx.strokeStyle = "#475067";
       ctx.lineWidth = 2;
       ctx.stroke();
       ctx.fillStyle = "#e8eefc";
       ctx.font = "800 18px system-ui, Segoe UI, Arial";
       ctx.fillText(b.label, bx + smallW / 2, by + smallH / 2);
       if (ui.justUp && hover) b.onClick();
     });

     ctx.restore();
   }

   function wrapText(ctx, text, x, y, maxW, lineH) {
     const paras = String(text).split(/\n+/);
     let cy = y;
     for (const para of paras) {
       const words = para.split(/\s+/).filter(Boolean);
       let line = "";
       for (const word of words) {
         const test = line ? `${line} ${word}` : word;
         if (ctx.measureText(test).width > maxW && line) {
           ctx.fillText(line, x, cy);
           cy += lineH;
           line = word;
         } else {
           line = test;
         }
       }
       if (line) {
         ctx.fillText(line, x, cy);
         cy += lineH;
       }
       cy += Math.floor(lineH * 0.4);
     }
     return cy;
   }

   function renderHelp() {
     ctx.save();
     ctx.fillStyle = "#0b0f14";
     ctx.fillRect(0, 0, W, H);

     // Header
     ctx.fillStyle = "#0a0f18";
     ctx.fillRect(0, 0, W, 86);
     ctx.fillStyle = "#e8eefc";
     ctx.font = "900 24px system-ui, Segoe UI, Arial";
     ctx.textAlign = "left";
     ctx.textBaseline = "middle";
     ctx.fillText("UNO — Help", 24, 42);

     // Reuse the same header HELP button slot as the game
     state._helpBtn = { x: W - 140, y: 20, w: 100, h: 46 };

     // Card
     const pad = 26;
     const panelX = pad;
     const panelY = 110;
     const panelW = W - pad * 2;
     const panelH = H - panelY - pad;
     roundedRect(ctx, panelX, panelY, panelW, panelH, 18);
     ctx.fillStyle = "#151c27";
     ctx.fill();
     ctx.strokeStyle = "#334058";
     ctx.lineWidth = 2;
     ctx.stroke();

     // Text
     const tx = panelX + 24;
     let ty = panelY + 22;
     const maxW = panelW - 48;

     ctx.fillStyle = "#e8eefc";
     ctx.font = "900 22px system-ui, Segoe UI, Arial";
     ctx.textAlign = "left";
     ctx.textBaseline = "top";
     ctx.fillText("Rules (this HTML game)", tx, ty);
     ty += 34;

     ctx.fillStyle = "#b9c6e6";
     ctx.font = "600 15px system-ui, Segoe UI, Arial";

     const helpText =
`Objective: be first to empty your hand.

On your turn: play a matching card (color OR value) or a Wild.
If you have no play, you must draw 1. If the drawn card is playable, you may play it; otherwise your turn ends.

Action cards:
- SKIP: next player loses their turn
- REVERSE: direction flips
- +2: next player draws 2 and loses their turn

Wild cards:
- WILD: choose the next active color
- WILD +4: choose color; next player draws 4 and loses turn

Wild +4 restriction (enabled): you may only play +4 if you have NO card matching the current active color.

UNO (enabled): when you play down to exactly 1 card, click UNO within 5 seconds or you’ll draw 2 at the start of your next turn.`;

     ty = wrapText(ctx, helpText, tx, ty, maxW, 20);

     // Back button (same style as other overlays)
     const bw = 220, bh = 54;
     const bx = W - bw - 30;
     const by = 16;
     const hover = ui.mouseX>=bx && ui.mouseX<=bx+bw && ui.mouseY>=by && ui.mouseY<=by+bh;
     roundedRect(ctx, bx, by, bw, bh, 12);
     ctx.fillStyle = hover ? "#2b3340" : "#222a36";
     ctx.fill();
     ctx.strokeStyle = "#475067";
     ctx.lineWidth = 2;
     ctx.stroke();
     ctx.fillStyle = "#e8eefc";
     ctx.font = "800 18px system-ui, Segoe UI, Arial";
     ctx.textAlign = "center";
     ctx.textBaseline = "middle";
     ctx.fillText("BACK", bx + bw/2, by + bh/2);
     if (ui.justUp && hover) state.phase = "title";

     ctx.restore();
   }

  function processClicks() {
    for (const b of buttons) {
      if (b.disabled) continue;
      if (ui.justUp && hitRect(ui.mouseX, ui.mouseY, b)) {
        b.onClick();
        return;
      }
    }

    if (state.phase === "game" || state.phase === "tutorial") {
      const player = state.players[state.current];
      const hand = player.hand;
      const rects = computeHandCardRects(hand);
      for (let i = rects.length - 1; i >= 0; i--) {
        if (ui.justUp && hitRect(ui.mouseX, ui.mouseY, rects[i])) {
          playCardFromHand(i);
          return;
        }
      }
    }
  }

  function tutorialForceSetup() {
    // Deterministic setup so the tutorial steps are always achievable.
    // This runs once when tutorial starts.
    if (!state.tutorial.enabled || state.tutorial.step !== 0 || state.tutorial._setupDone) return;
    state.tutorial._setupDone = true;
    state.tutorial._showSkipOverlay = false;

    for (const p of state.players) p.hand.length = 0;
    state.deck = makeDeck();
    state.discard = [];

    // Start with: top discard = Red 5
    state.discard.push({color:"R", value:"5"});
    state.activeColor = "R";

    // Player 1 gets a forced playable (Red 9) + filler
    state.players[0].hand.push({color:"R", value:"9"});
    state.players[0].hand.push({color:"G", value:"1"});

    // Player 2 gets a forced Skip that matches current color
    state.players[1].hand.push({color:"R", value:"S"});
    state.players[1].hand.push({color:"B", value:"2"});

    // Player 3 gets a Wild +4 but ALSO a red card (so +4 is illegal right now)
    state.players[2].hand.push({color:"W", value:"WD4"});
    state.players[2].hand.push({color:"R", value:"0"});

    // Player 4 gets a Wild
    state.players[3].hand.push({color:"W", value:"W"});
    state.players[3].hand.push({color:"Y", value:"7"});

    state.current = 0;
    state.direction = 1;
    state.pendingDraw = 0;
    state.pendingSkip = false;
    state.unoRequiredForPlayer = null;
    state.unoCallWindow = 0;

    announce("Tutorial: follow the steps on the left", 1800);
    startTurn();
  }

  function tutorialInstruction() {
    const s = state.tutorial.step;
    if (s === 0) return "Step 1: Player 1, click RED 9 to play it.";
    if (s === 1) return "Step 2: Player 2, click RED SKIP to skip Player 3.";
    if (s === 2) return "Step 3: (Auto) Player 3 is skipped. Click CONTINUE.";
    if (s === 3) return "Step 4: Player 4, play WILD and choose BLUE.";
    if (s === 4) return "Step 5: Player 1, draw a card (deck/DRAW).";
    if (s === 5) return "Step 6: UNO demo. Player 1, play down to 1 card then click UNO!";
    if (s === 6) return "Step 7: Wild +4 rule. Player 3: try WILD +4 (should be blocked), then play RED 0.";
    if (s === 7) return "Step 8: Now Player 3 has no RED. Play WILD +4 (allowed), choose any color.";
    return "Tutorial complete.";
  }

  function tutorialAdvanceIf(condition) {
    if (!state.tutorial.enabled) return;
    if (!condition) return;
    state.tutorial.step++;
    announce("Good!", 900);
    if (state.tutorial.step >= 8) {
      state.tutorial.enabled = false;
      state.phase = "game";
      announce("Tutorial finished. Normal game continues.", 1800);
    }
  }

  function tutorialAllowClickContinueOverlay() {
    // Used for steps that require a manual acknowledgement (like a skip).
    drawCenteredOverlay("Tutorial", tutorialInstruction(), [
      { label: "CONTINUE", onClick: () => { state.tutorial.step++; announce("Continuing...", 900); } }
    ]);
  }

  function renderTutorialOverlay() {
    ctx.save();
    roundedRect(ctx, 22, 100, 520, 170, 14);
    ctx.fillStyle = "rgba(21,28,39,0.92)";
    ctx.fill();
    ctx.strokeStyle = "#334058";
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.fillStyle = "#e8eefc";
    ctx.font = "900 18px system-ui, Segoe UI, Arial";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.fillText("INTERACTIVE TUTORIAL", 40, 118);

    ctx.fillStyle = "#b9c6e6";
    ctx.font = "650 15px system-ui, Segoe UI, Arial";
    ctx.fillText(tutorialInstruction(), 40, 150);

    ctx.fillStyle = "#8fa3cc";
    ctx.font = "600 13px system-ui, Segoe UI, Arial";
    ctx.fillText("Only the correct action will advance the step.", 40, 195);

    // Exit tutorial
    const bx = 40, by = 225, bw = 120, bh = 34;
    const hover = ui.mouseX>=bx && ui.mouseX<=bx+bw && ui.mouseY>=by && ui.mouseY<=by+bh;
    roundedRect(ctx, bx, by, bw, bh, 10);
    ctx.fillStyle = hover ? "#3a2230" : "#2c1b25";
    ctx.fill();
    ctx.strokeStyle = "#6a3c54";
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.fillStyle = "#ffe8f3";
    ctx.font = "800 14px system-ui, Segoe UI, Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("EXIT", bx + bw/2, by + bh/2);
    if (ui.justUp && hover) {
      state.tutorial.enabled = false;
      state.phase = "game";
      announce("Tutorial exited. Normal game continues.", 1800);
    }

    ctx.restore();
  }

  function tick() {
     if (state.phase === "title") renderTitle();
    else if (state.phase === "setup") { renderSetup(); }
    else if (state.phase === "help") { renderHelp(); }
     else if (state.phase === "game") { renderTable(); runAiStep(); processClicks(); }
    else if (state.phase === "tutorial") {
      tutorialForceSetup();
      renderTable();

       // Step 2: explain the automatic skip (requires acknowledgement).
       // Also, for robustness: if we're ever on "Player 3" during step 2,
       // apply the pending skip immediately and keep showing the overlay.
       if (state.tutorial.step === 2) {
         if (state.pendingSkip) {
           startTurn();
         }
         tutorialAllowClickContinueOverlay();
       } else {
         renderTutorialOverlay();
       }

      processClicks();
    }
     else if (state.phase === "colorPick") {
       // AI doesn't use the color picker UI, but we still run steps in case.
       runAiStep();
       renderColorPick();
     }
    else if (state.phase === "handoff") { renderHandoff(); }
    else if (state.phase === "gameOver") { renderGameOver(); }

    ui.justDown = false;
    ui.justUp = false;

    requestAnimationFrame(tick);
  }

  // start
  state.phase = "title";
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
